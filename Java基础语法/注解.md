# 注解

`Annotation`

注释会被编译器直接忽略，注解则可以被编译器打包进入`.class`文件，因此，注解是一种用作标注的“元数据”。

**注解的作用**

从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。

## **内置注解**

- `@Override`：让编译器检查该方法是否正确地实现了覆写，只适用于修饰方法；
- `@deprecated`：表示不鼓励程序员使用该元素，但仍能使用，可以用于修饰方法，属性，类；
- `@SuppressWarnings`：告诉编译器忽略此处代码产生的警告，该注释需要添加一个参数。

这类注解不会被编译进入`.class`文件，它们在编译后就被编译器扔掉了。

## **元注解**

`meta-annotation`

元注解的作用就是负责注解其他注解

- `@Target`：可以定义`Annotation`能够被应用于源码的哪些位置

  参数：

  - 类或接口：`ElementType.TYPE`；
  - 字段：`ElementType.FIELD`；
  - 方法：`ElementType.METHOD`；
  - 构造方法：`ElementType.CONSTRUCTOR`；
  - 方法参数：`ElementType.PARAMETER`。

```java
@Target(value = {ElementType.METHOD,ElementType.Type})  // 表明注解可以用于方法，类，接口等
```

- `@Retention`：定义了`Annotation`的生命周期

  参数：

  - 仅编译期：`RetentionPolicy.SOURCE`；
  - 仅`class`文件：`RetentionPolicy.CLASS`；
  - 运行期：`RetentionPolicy.RUNTIME`。

   生命周期长短：`RUNTIME > CLASS > SOURCE`

  如果`@Retention`不存在，则该`Annotation`默认为`CLASS`。通常我们自定义的`Annotation`都是`RUNTIME`

```java
@Retention(value = RetentionPolicy.RUNTIME)
```

- `@Documented`：说明该注解将被包含在`JavaDoc`中

- `@Inherited`：说明子类可以继承父类中的该注解

  `@Inherited`仅针对`@Target(ElementType.TYPE)`类型的`annotation`有效，并且仅针对`class`的继承，对`interface`的继承无效

- `@Repeatable`：可以定义`Annotation`是否可重复

## 自定义注解

```java
@Target({ElementType.TYPE,ElementType.METHOD}) // 元注解
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation {   // 自定义注解
    // 注解的参数：参数类型 + 参数名(),default后面为默认值;
    String name() default "";
    int age();
    String[] schools() default {"str1","str2"};
}
@MyAnnotation(age = 18,name = n)
public viod method() {}
```

如果参数名称是`value`，且只有一个参数，那么可以省略参数名称。

