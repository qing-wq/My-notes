# 多线程机制

## 基本概念

 **进程** `process `  

进程时执行程序的一次过程，他是一个动态的概念，是系统资源分配的单位

  **线程** `Thread`  

通常在一个进程中可以包含多个线程,在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，`gc`线程

`main()`称之为主线程，执行整个程序

线程是CPU调度和执行的单位，线程不一定立即执行，CPU安排调度

很多多线程都是模拟出来的，真正的多线程是指有多个CPU，即多核，如服务器

如果是模拟多线程，即在一个CPU的情况下，在同一时间点，CPU只能执行一个代码，因为切换的快所以有同时执行的错觉

当存在多个线程时，`JVM`轮流切换各个线程使用CPU资源

## 线程状态

1. 创建

2. 就绪状态

3. 运行状态

4. 中断

   中断产生的原因

   - `JVM`将CPU切换给其他线程
   - `sleep(int millsecond)`方法，该方法为`Thread`类的类方法，线程执行该方法后进入休眠状态，经过参数`millsecond`指定的毫秒数之后重新进入线程队列中排队
   - `wait()`方法，使当前线程进入等待状态，等待状态的线程不会主动加入线程队列，需要由其他线程调用`nitify()`方法通知他重新加入线程队列
   - 某个线程使用CPU期间阻塞

5. 死亡

## 线程调度与优先级

`JVM`中的线程调度负责器负责管理线程，调度器把线程的优先级分为十个等级，由`Thread`类中的类常量表示，每个线程的优先级都在1~10之间，即`Thread.MIN_PRIORITY`和`Thread.MAX_PRIORITY`之间，Java会将优先级高的线程执行完毕再执行优先级较低的线程

如果没有明确的设置优先级，则每个线程的优先级都是5

优先级可以通过`setPriority(int grade)`方法调整

*在实际编程时，不提倡使用线程的优先级来保证算法的正确执行。要编写跨平台的多线程代码，必须假设线程在任何时候都有可能被剥夺CPU的使用权*

## 创建线程

- **使用`Thread`类的子类创建线程**

  1. 自定义类继承`Thread`类
  2. 重写`run()`方法，编写线程执行体
  3. 创建线程对象，调用`start()`方法启动线程

```java
public class StratThread1 extends Thread {  // 创建一个类继承Thread类
	@Override
    public void run() {
        // 线程体
    }
	public static void main(String[] args) {
    	Thread t = new StartThread1();
    	t.start();   // 主线程调用start()方法，多线程交替执行
        t.run();     // 主线程调用run()方法，执行完run()方法再执行主线程，只有一条执行路径
	}
}
```

弊端：由于Java不支持多继承，`Thread`类的子类不能继承其他类

- **使用`Runnable`接口创建线程**

  1. 定义类继承`Runnable`接口
  2. 重写`run()`方法，编写线程执行体
  3. 创建线程对象，调用`start()`方法启动线程

```java
public class A implements Runnable {  // 创建一个类实现Runnable接口
    @Override 
    public void run() {
        // 线程体
    }
    public static void main(String args[]) {
        A a = new A();
        new Thread(a).start();  // 相当于下面两句话
        
        // 创建线程对象，通过线程对象来开启线程 ->代理思想
//        Thread thread = new Thread(a);
//        thread.start();
    }
}
```

其他写法

```java
public class Test {
    public static void main(String[] args) {
        // 常规写法
        A a = new A();
        new Thread(a).start();
        // 使用匿名类
        Thread t = new Thread(new Runnable() {
            public void run() {
                System.out.println("aaaa");
            }
        });
        t.start();
        // 使用λ表达式
        Thread t = new Thread(()->{
            System.out.println("aaaaa");
        });
        t.start();
    }
}
class A implements Runnable {
    @Override
    public void run() {
        System.out.println("aaa");    
    }
    
}
```

- **使用`callable`接口**(了解)

当我们提交一个`Callable`任务后，我们会同时获得一个`Future`对象，然后，我们在主线程某个时刻调用`Future`对象的`get()`方法，就可以获得异步执行的结果。在调用`get()`时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么`get()`会阻塞，直到任务完成后才返回结果

`Future<V>`接口表示一个未来可能会返回的结果

![image-20220107200300877](Thread.assets/image-20220107200300877.png)

![image-20220107134008952](Thread.assets/image-20220107134008952.png)

## 线程常用方法

- **`sleep(int millsecond)`**

该方法可以让线程进入休眠状态，休眠时间为参数`millsecond`指定的毫秒数

如果线程在休眠时被打断，就会抛出`InterruptedException`异常，因此必须在`try-catch`异常中调用`sleep()`方法

`sleep`方法不会释放锁(抱着锁睡觉)

用`sleep`可以模拟网络延时，倒计时等

**模拟倒计时**

```java
public static void tenDown() throws InterruptedException {
    int num = 10;
    while(true) {
        Thread.sleep(1000);
        System.out.println(num--);
        if(num<=0){
            break;
        }
    }
}
```

**计时器**

```java
public static void main(String[] args) {
    Date startTime = new Date(System.currentTimeMillis());  //获取系统当前时间
    while(true) {
        try{
            Thread.sleep(1000);
            System.out.println(new SimplyDateFormat(pattern:"HH:mm:ss").format(startTime));
            startTime = new Date(System.currentTimeMillis()); // 更新当前时间
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

- **`yield()`**

礼让线程，让当前正在执行的线程暂停，但不阻塞，即将线程由运行状态转为就绪状态

礼让不一定成功，因为CPU重新调度时可能会将CPU再次分配给该线程

- **`join()`**

线程联合

一个线程A在占有CPU资源期间，可以让其他线程调用`join()`和本线联合。如果A在占有CPU资源期间一旦联合了B，那么A线程将立即中断执行，一直到B执行完毕，A再重新排队。如果B已经结束，那么`B.join()`不会产生任何效果

- **`isAlive()`**

当线程处于新建状态时，线程调用该方法返回`false`。当一个线程调用`start()`并占有资源开始，到线程死亡为止，调用该方法返回的是`true`

- **`currentThread()`**

该方法是`Thread`类的类方法，可以直接用类名调用，该方法返回当前正在占用CPU资源的线程

- **`interrupt()`**

当一些线程调`sleep`方法处于休眠状态时，一个占有CPU资源的线程可以让休眠的线程调用`interrupt`方法“吵醒”自己，即导致在休眠的线程发生`InterruptedException`异常，从而结束休眠

## 静态代理

23种设计模式之一

- 真实对象和代理对象要实现同一个接口
- 代理对象要代理真实角色

好处：

- 代理对象可以做很多真实对象做不到的事

- 真实对象专注做自己的事

使用`Runnable`接口时就体现了该思想

```java
// 实例
public class StacticProxy {
    public static void main(String[] args) {
        You you = new You();
        WeddingCompany weddingCompany = new WeddingCompany(you);
        weddingCompany.getMarry();
    }
}

interface Marry{
    void getMarry();
}

// 你 真实角色
class You implements Marry {

    @Override
    public void getMarry() {
        System.out.println("结婚中，超开心");
    }
}

// 婚庆公司 代理角色
class WeddingCompany implements Marry {
    // 定义帮助结婚的目标
    private Marry target;

    public WeddingCompany(Marry target) {
        this.target = target;
    }

    @Override
    public void getMarry() {
        before();
        this.target.getMarry();
        after();
    }

    private void before() {
        System.out.println("结婚前，布置现场");
    }
    private void after() {
        System.out.println("结婚后，收尾款");
    }
}
```

## 观测线程状态

`thread.getState()`方法可以返回当前线程的状态

返回值：

| 返回值       | 状态                                                       |
| ------------ | ---------------------------------------------------------- |
| `NEW`        | 尚未启动的线程处于此状态                                   |
| `RUNNABLE`   | 在Java虚拟机中执行的线程处于此状态                         |
| `BLOCKED`    | 被阻塞等待监听器锁定的线程处于此状态                       |
| `WAITING`    | 正在等待另一个线程执行动作达到指定等待时间的线程处于此状态 |
| `TERMINATED` | 已退出的线程处于此状态                                     |

**观测线程状态**

```java
public static void main(String[] args) {
    Thread thread = new Thread(()->{
        // 线程体
    });
    // 观察状态
    Thread.State state = thread.getSatate();
    System.out.println(state);  // 输出new之后的线程状态
    
    // 启动后
    thread.start();
    state = thread.getState();
    System.out.println(state);  // 输出run后的线程状态
    
    while(state!=Thread.State.TERMINATED) {
        Thread.sleep(100);
        state = thread.getState();  // 更新线程状态
        System.out.println(state);  // 输出状态
    }
} 
```

## 守护线程

线程分为用户线程和守护线程

`JVM`必须确保用户线程执行完毕，但不必等待是守护线程执行完毕

守护线程包括：后台记录操作日志，监控内存，垃圾回收等

## 线程同步

**并发问题**：当多个线程操作同一资源时，线程不安全，数据紊乱

线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面的线程使用完毕，下一个线程再使用

**锁机制**：若干个线程都需要使用一个`synchronized`修饰的方法，多个线程调用该方法必须遵守同步机制：当一个线程使用该方法时，其他线程想使用该方法就必须等待(相当于加锁)

### **同步方法**

```java
public synchronized void method(int args) {}
```

方法中需要修改的内容才需要锁，锁的太多，会浪费资源

在多线程竞争的情况下，加锁释放锁会导致较多上下文切换和调度延时，引起性能问题

如果优先级高的线程等待优先级低的线程释放锁会导致优先级倒置，引起性能问题

加锁会导致性能问题，但能提高安全性

### **同步块**

```java
synchronized (Obj) {
    // 修改Obj的代码块
}
```

`Obj`称为同步监视器，`Obj`可以是任何对象，但应使用共享实例作为同步监视器，因为锁的对象一定是被多线程操作的变化的量，否则无用

同步方法中无需指定同步监视器，因为同步方法的同步监视器就是`this`，就是这个对象本身，或者是`class`

### 死锁

多个线程相互抱着对方的资源，形成僵持

产生死锁的四个必要条件：

1. 互斥条件：一个资源每次只能被一个进程使用
2. 请求与保持条件：一个进程因请求资源而阻塞时，对方对已获得的资源保持不放
3. 不剥夺条件：进程已获得的资源，在未使用完之前不能强行剥夺
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系

解决办法：破除其中任一条件即可

下面是一个死锁：

![image-20220108144109587](Thread.assets/image-20220108144109587.png)

解决方法：将嵌套的两把锁拿到外面

### `ReenTrantLock`类

Java提供了更强大的线程同步机制——通过显示定义同步锁对象来实现同步。同步锁使用`Lock`对象充当

`java.util.concurrent.locks.Lock`接口是控制多个线程对共享资源进行访问的工具

`ReenTrantLock`类(可重入锁)实现了`Lock`，它拥有与`synchronized`相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是`ReentrantLock`,可以显示加锁，释放锁

对同一个线程，可以在获取到锁以后继续获取同一个锁。`JVM`允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。

```java
class A implements Runnable{
    // 定义lock锁
    private final ReentrantLock lock = new ReenTrantLock();
    
    public void run() {
        while(true) {
            try{
                lock.lock();  //加锁
                
                // 需要保证安全的线程体
                
            } finally{
                // 解锁
                lock.unlock();
            }
        }
    }
}
```

**`synchronized`与`Lock`的对比**

- `Lock`是显示锁，需要手动开启和关闭，`synchronized`是隐式锁，出了作用域自动释放
- `Lock`只有代码块锁，`synchronized`有代码块锁和方法锁
- 使用`Lock`锁，`JVM`将花费较少时间来调度线程，性能更好，并且拓展性好(有很多子类)
- 优先使用顺序：`Lock`>同步代码块>同步方法

### `JUC`

即`java.util.concurrent`,另外一个并发领域，使用该包提供的线程安全的并发集合可以大大简化多线程编程

| interface | non-thread-safe           | thread-safe                                |
| :-------- | :------------------------ | :----------------------------------------- |
| `List`    | `ArrayList`               | `CopyOnWriteArrayList`                     |
| `Map`     | `HashMap`                 | `ConcurrentHashMap`                        |
| `Set`     | `HashSet / TreeSet`       | `CopyOnWriteArraySet`                      |
| `Queue`   | `ArrayDeque / LinkedList` | `ArrayBlockingQueue / LinkedBlockingQueue` |
| `Deque`   | `ArrayDeque / LinkedList` | `LinkedBlockingDeque`                      |

```java
public class TestJUC {
    public static void main(String[] args) {
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<String>();
        for (int i=0;i < 1000;i++) {
            new Thread(()->{
                list.add(Thread.currentThread().getName());
            }).start();
        }
        Thread.sleep(1000);
    }
}
```

### 线程通信

这是一个线程同步问题，生产者和消费者共享同一资源，并且生产者和消费者之间相互依赖，互为条件

Java提供了几个方法解决线程之间的通信问题

| 方法                 | 作用                                                       |
| -------------------- | ---------------------------------------------------------- |
| `wait()`             | 表示线程等待，直到其他线程通知才会被唤醒。会释放锁         |
| `wait(long timeout)` | 表示等待指定的毫秒数                                       |
| `notify()`           | 唤醒一个正在等待状态的线程                                 |
| `notifyAll()`        | 唤醒同一个对象上所有调用wait方法的线程，优先级高的优先调度 |

#### 管程法

生产者与消费者模式

生产者：负责生产数据的模块

消费者：负责处理数据模块

缓冲区：生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据

```java
package com;

public class Test {
    public static void main(String[] args) {
        SynContainer container = new SynContainer();
        Produtor produtor = new Produtor(container);
        Consumer consumer = new Consumer(container);
        produtor.start();
        consumer.start();
    }

}

// 生产者
class Produtor extends Thread {
    SynContainer container ;
    public Produtor(SynContainer container) {
        this.container = container;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            container.push(new Chicken(i));
            System.out.println("生产了"+ i + "只鸡");

        }
    }
}

// 消费者
class Consumer extends Thread {
    SynContainer container ;
    public Consumer(SynContainer container) {
        this.container = container;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("消费了-->"+ container.pop().id+"只鸡");
        }
    }
}

// 产品
class Chicken{
    int id;
    public Chicken(int id) {
        this.id = id;
    }
}

// 缓冲区
class SynContainer{
    // 需要一个容器大小
    Chicken[] chickens = new Chicken[10];
    // 容器计数器
    int count = 0;

    //生产者放入产品
    public synchronized void push(Chicken chicken) {
        // 如果容器满了，就需要等待消费者
        if (count == chickens.length) {
            // 生产等待
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // 如果没有满，生产者就需要丢入产品
        chickens[count]=chicken;
        count++;

        // 唤醒消费者
        this.notifyAll();
    }
    public synchronized Chicken pop() {
        // 判断是否能消费
        if (count==0) {
            // 等待生产者生产
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        count--;
        Chicken chicken = chickens[count];
        this.notifyAll();
        return chicken;
    }

}
```

#### 信号灯法

设置标志位

## 线程池

提前创建多个线程，放入线程池中，可以避免频繁创建销毁，实现重复利用

好处：

- 提高响应速度(减少创建新线程的时间)
- 降低资源消耗(重复利用线程池中的线程)
- 便于管理
  - `corePoolSize`:  核心池大小
  - `maximunPoolSize`:   最大线程数
  - `keepAliveTime`:  线程没有任务时最多保持多长时间后终止

线程池相关API：`ExecutorService` 和 `Executors`

`ExectorService`:  真正的线程池接口，常见子类`ThreadPoolExecutor`

方法：

- `execute(Runnable command)`：执行命令，没有返回值，一般用来执行Runnable
- `Future<T> submit(CallAble<T> task)`:  执行命令，有返回值，一般用来执行Callable
- `shutdown()`：关闭线程池

`Executors`：工具类，线程池的工厂类，用于创建并返回不同类型的线程池

```java
public ststic void main(String[] args) {
    //1.创建服务，创建一个容量为10的线程池
    ExecutorService service = Executor.newFixedThreadPool(nThread:10);
    
    // 执行 通过execute方法提交线程
    service.execute(new MyThread());   // MyThread代表不同的线程
    service.execute(new MyThread());
    service.execute(new MyThread());
    service.execute(new MyThread());
    
    // 关闭线程池
    service.shutdown();
}
```

