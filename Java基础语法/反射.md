# 反射

**动态语言**：运行时代码可以根据某些条件改变自身结构

如：`Object-C，C#，js，PHP，Python`等

**静态语言**：运行时结构不可改变

如：`Java，C，C++`

但`Java`具有一定的动态性，即可以利用反射机制获得类似动态语言的特性。

<u>反射就是基于类可以获取类的属性，方法，以及关联的内部构造（如配置信息），用`ClassLoad`获取。</u>

`Reflection(反射)`是Java被视为动态语言的关键。反射机制允许程序在执行期间借助`Reflection API`取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。

==常用方法==

| 方法                                      | 功能说明                              |
| ----------------------------------------- | ------------------------------------- |
| `static Class forName(String name)`       | 返回指定类名`name`的`Class`对象       |
| `Object newInstance()`                    | 调用构造函数，创建一个`Class`对象实例 |
| `getName()`                               | 获得`Class`对象                       |
| `Class getSuperClass()`                   | 返回当前`Class`对象的父类的Class对象  |
| `Class[] getInterfaces()`                 | 获取当前`Class`对象的接口             |
| `ClassLoader getClassLoader()`            | 返回该类的加载器                      |
| `Constructor[] getConstructors()`         | 返回类的构造器                        |
| `Method getMethod(String name,parameter)` | 返回一个`Method`对象                  |
| `Field[] getDelaredFields()`              | 返回`Field`对象的一个数组             |

## **类的加载过程**

1. 加载：通过类的加载器加载，生成一个`java.lang.Class`对象

2. 链接：将Java类的二进制代码合并到JAM的运行状态之中

   - 验证

   - 准备

   - 解析

3. 初始化

**动态加载**

`JVM`在执行Java程序的时候，并不是一次性把所有用到的`class`全部加载到内存，而是第一次需要用到`class`时才加载

**Java内存分析**

堆：存放`new`对象和数组，可以被所有线程共享，不会存放别的对象的引用

栈：存放基本类型，引用对象的变量

方法区：可以被所有线程共享，包含所有的`class`和`static`变量

#### **类加载器**

`ClassLoader`

作用：将`class`文件字节码内容加载到内存中，并将这些静态类数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的`java.lang.Class`对象，作为方法区中类数据的访问入口

JVM规范定义了如下加载类：

- 引导类加载器：负责Java平台核心库，即根加载器
- 拓展加载器：负责将`jre/lib/ext`目录下的`jar`包或`-D java.ext.dirs`指定目录下的`jar`包装入工作库
- 系统类加载器：负责`java -classpath`或`-D java.class.path`所指目录下的类与`jar`包装入工作，最常用的加载器

以上三种加载器为父子关系

类缓存：标准的`JavaSE`类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载(缓存)一段时间。不过`JVM`垃圾回收机制可以回收这些Class对象

```java
 public class Test {
     public static void main (String[] args) {
         // 获取系统类的加载器
         ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
         System.out.println(systemClassLoader);
         // 获取系统类加载器的父类加载器->拓展类加载器
         ClassLoader parent  = systemClassLoader.getParent();
         // 获取拓展类加载器的父类加载器->根加载器
         ClassLoader parent1 = parent.getparent();//由于根加载器是用c/c++编写，返回值是null
         // 测试当前类是由哪个加载器加载的
         ClassLoader classLoder = Class.forName("com.…….Test").getClassLoader();
         // 测试JDK内置类是谁加载的
         classLoader = Class.forName("java.lang.Object").getClassLoader();  // null
     }
 }
```

#### **类的初始化**

什么时候会发生类的初始化？

- 类的主动引用
  - 当JVM启动，先初始化main方法所在的类
  - new一个类的对象
  - 调用类的静态成员(除了final常量)和静态方法
  - 使用`java.lang.reflect`包的方法对类进行反射调用
  - 当初始化一个类，如果其父类没有被初始化，则会先初始化他的父类
- 类的被动引用
  - 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类的初始化
  - 通过数组定义类引用，不会触发此类的初始化
  - 引用常量不会触发此类的初始化(常量在链接阶段就存入调用类的常量池中了)

```java
// 主动引用
Son son = new Son();
//反射也会产生主动引用
Class.forName("com.kuang.reflection.Son");
// 被动引用
System.out.println(Son.b);  // b为静态字段
Son[] array = new Son[5];
System.out.println(Son.M);  // M为静态变量
```

## 获取Class对象

```java
// 获取class对象
public class Test {
    public static void main(String[] args) throws ClassNotFoundException {
        Person person = new Student();  // Person为Student的父类
        
        // 方式一：通过实例化对象获得
        Class c1 = person.getClass();  // 返回值为Student类
        System.out.println(c1.hashCode());   // 可以通过打印hashCode来判断是否是同一个类
        
        // 方式二：forname + 完整类名获得
        Class c2 = Class.forName("com.kuang.reflection.Student");
        
        // 方式三：通过类名.class获得
        Class c3 = Student.class;
        
        // 方式四：基本包装类型都有一个Type属性
        Class c4 = Integer.TYPE;
    }
}
```

**哪些类型可以有`Class`对象？**

- `class`：外部类，内部类(成员内部类，静态内部类)，局部内部类，匿名内部类
- `interface`：接口
- `[]`：数组
- `enum`：枚举
- `annotation`：注解
- 基本数据类型
- `void`

## 获取类运行时的结构

### 访问字段

- `Field getField(name)`：根据字段名获取某个`public`的`field`（包括父类）
- `Field getDeclaredField(name)`：根据字段名获取当前类的某个field（不包括父类）
- `Field[] getFields()`：获取所有`public`的`field`（包括父类）
- `Field[] getDeclaredFields()`：获取当前类的所有`field`（不包括父类）

```java
User user = new User();   // user为一个类的实例
c1 = user.getClass();    // 获取Class对象
// 获得类属性
Field[] fields = c1.getFields();  // 只能找到public属性
fields = c1.getDeclaredFields();   // 找到全部的属性
for(Field field : fields) {
    System.out.println(field);
}
Field f = c1.geDeclaredtField("name");  // 获得name属性
Object value = f.get(user);   // 获得user的name属性的值
```

上述代码先获取`Class`实例，再获取`Field`实例

- `Field.get(Object)`获取指定实例的指定字段的值

- `Field.set(Object, Object)`设置字段值实现的，其中第一个`Object`参数是指定的实例，第二个`Object`参数是待修改的值

一个`Field`对象包含了一个字段的所有信息

- `getName()`：返回字段名称，例如，`"name"`；
- `getType()`：返回字段类型，也是一个`Class`实例，例如，`String.class`；
- `getModifiers()`：返回字段的修饰符，它是一个`int`，不同的`bit`表示不同的含义。

### 访问方法

- `Method getMethod(name, Class...)`：获取某个`public`的`Method`（包括父类）
- `Method getDeclaredMethod(name, Class...)`：获取当前类的某个`Method`（不包括父类）
- `Method[] getMethods()`：获取所有`public`的`Method`（包括父类）
- `Method[] getDeclaredMethods()`：获取当前类的所有`Method`（不包括父类）

```java
// 获得类的方法
Method[] methods = c1.getMethods();  // 获得本类及父类的全部public方法
methods = c1.getDeclaredMethods();   // 获得本类所有方法
for (Method method : methods) {
    System.out.println(method);
}
// 获得指定方法,因为存在方法重载，需要传入...parameterTypes参数来判断获取到的是哪个方法
Method getName = c1.getDeclaredMethod(name:"getName",...parameterTypes:null);
Method setName = c1.getDeclaredMethod(name:"setName",...parameterTypes:String.class);
```

一个`Method`对象包含一个方法的所有信息：

- `getName()`：返回方法名称，例如：`"getScore"`；
- `getReturnType()`：返回方法返回值类型，也是一个Class实例，例如：`String.class`；
- `getParameterTypes()`：返回方法的参数类型，是一个Class数组，例如：`{String.class, int.class}`；
- `getModifiers()`：返回方法的修饰符，它是一个`int`，不同的`bit`表示不同的含义。

使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）

### 调用构造方法

通过`Class`实例获取`Constructor`的方法如下：

- `getConstructor(Class...)`：获取某个`public`的`Constructor`；
- `getDeclaredConstructor(Class...)`：获取某个`Constructor`；
- `getConstructors()`：获取所有`public`的`Constructor`

```java
//获得构造器
Constructor[] constructors = c1.getConstructors();  // 获得public构造器
constructors = c1.getDelaredConstructor();  // 获得所有构造器
for (Constructor construstor : constructors) {
    System.out.println(constructor);
}
// 获得指定的构造器
Constructor declaredConstructor = c1,getDeclaredConstructor(String.class,int.class,int.class);
```

## 通过反射动态创建

通过`Constructor`实例可以创建一个实例对象：`newInstance(Object... parameters)`

```java
Class c1 = Class.forName("User");  // 得到Class对象
// 构造一个对象
User user = (User)c1.newInstance(); // 本质为调用了子类的无参构造
// 通过构造器创建对象(有参构造)
Constructor constructor = c1.getDeclaredConstructor(String.class,int.class,int.class);
User User2 = (User)constructor.newInstance("小小小春实",3,09);
// 通过反射操作属性
User user3 = (User)c1.newInstance();
Field name = c1.getDeclaredField("name");  // 获取属性
name.setAccessible(true);  // 使用setAccessible()访问private属性
name.set(user3,"小春实");  // 修改name属性
// 通过反射调用方法
User user4 = (User)c1.newInstance();
Method setName = c1.getDelaredMethod(name:"setName",String.class);  // 通过反射获取方法
// invoke(对象,方法参数)：	激活函数 
setName.invoke(user4,"chunshi");
System.out.println(user3.getName());  // chunshi
```

- `Object invoke(Object obj,Object args)`
  - 若原方法为静态方法，`Object  obj`可为`null`
  - 若原方法形参为空列表，则`Object[] args`为`null`

- `setAccessible(true)` ：关闭安全检查机制
  - `method,field,Constructor`对象都有该方法
  - 提高反射效率。如果一个代码中必须使用反射，而该代码块被频繁的调用，可以将其设置为true
  - 可以访问`private`成员

性能问题：普通程序执行`->`通过反射(关闭安全检测)`->`通过反射执行

此外，`setAccessible(true)`可能会失败。如果JVM运行期存在`SecurityManager`，那么它会根据规则进行检查，有可能阻止`setAccessible(true)`。例如，某个`SecurityManager`可能不允许对`java`和`javax`开头的`package`的类调用`setAccessible(true)`，这样可以保证JVM核心库的安全

## 反射与泛型

Java采用泛型擦除机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题，但是一旦编译完成，所有的泛型有关的数据全部擦除。运用反射，我们可以操作这些被擦除的泛型

相关类型：

- `ParameterizedType`：表示一种参数化类型
- `GenenricArrayType`：表示一种元素类型是   参数化类型或者类型变量   的数组类型
- `TypeVariable`：各种类型变量的公共父接口
- `WildcardType`：代表一种通配符类型表达式

```java
public class Test {
    public void test1(Map<String,User> map,List<User> list) {   //泛型在参数中
        ...
    }
    public Map<String,User> test2 {   // 泛型在返回值中
        ...
        return null;
    }
    public static void main(String[] args) throws NoSuchMethodException {
        // 获取方法
        Method method = Test.class.getMethod("test1",Map.class,List.class);
        // 获取方法的参数类型(Map,List)
        Type[] genericParameterTypes = method.getGenericParameterTypes();
        for(Type genericParameterType : genericParameterTypes) {
            System.out.println(genericParameterType);
            if(genericParameterType instanceof parameterizedType) {
                // 获取泛型中的的实际参数(<String,User>,<User>)
                Type[] actualTypeArguments = ((ParameterizedType)genericParameterType).getActualTypeArgument();
                for(Type actualTypeArgument : actualTypeArguments) {
                    System.out.println(actualTypeArgument);
                }
            }
        }
        method = Test.class.getMethod("test2",null);
        Type genericReturnType = method.getGenericReturnType();
        if (genericReturnType instanceof ParameterizedType) {
            Type[] actualTypeArguments = ((ParameterizedType)genericReturnType).getActualTypeArgument();
            for(Type actualTypeArgument : actualTypeArguments) {
                    System.out.println(actualTypeArgument);
            }
        }
    }
}
```

该部分仅作了解，难以理解可以尝试自己运行一下看输出结果

## 反射与注解

```java
Class c1 = Test.class;
// 通过反射获得注解
Annotation[] annotations = c1.getAnnotations();
for (Annotation annotation : annotations) {
    System.out.println(annotation);  //@com.kuang.Tablekuang(value=db_std)
}
// 获得注解的参数的值
TableKuang tablekuang = (TableKuang)c1.getAnnotation(TableKuang.class);
String value = tablekuang.value();
System.out.println(value); // db_std
// 获得类属性指定的注解
Field f = c1.getDelaredField("id");
Fieldkuang annotation = f.getAnnotation(Fieldkuang.class);
System.out.println(annotation.columnName()); // 打印注解的参数
System.out.println(annotation.type());  // int
System.out.println(annotation.length());  // 10

@TableKuang("db_std")  // value为形参名时可以省略不写直接传值
class Test {
    @Fieldkuang(columnName = "bd",type = "int",length = 10)
    private int id;
}
// 类名的注解
@Target(ElemenType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface TableKuang {
    String value();
}
// 属性的注解
@Target(ElemenType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@interface Fieldkuang {
    String columnName();
    String type();
    int length();
}
```

## 动态代理

`interface`不能实例化，所有`interface`类型的变量总是通过某个实例向上转型并赋值给接口类型变量的

Java标准库提供了一种动态代理`(Dynamic Proxy)`的机制：可以在运行期动态创建某个`interface`的实例。

常用方式：

```java
public interface Hello {
    void morning(String name);
}
// 编写实现类
public class HelloWorld implements Hello {
    public void morning(String name) {
        System.out.println("Good morning, " + name);
    }
}
// 创建实例，转型为接口并调用
Hello hello = new HelloWorld();
hello.morning("Bob");
```

还有一种方式是动态代码，我们仍然先定义了接口`Hello`，但是我们并不去编写实现类，而是直接通过`JDK`提供的一个`Proxy.newProxyInstance()`创建了一个`Hello`接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。`JDK`提供的动态创建接口对象的方式，就叫动态代理。

在运行期动态创建一个`interface`实例的方法如下：

1. 定义一个`InvocationHandler`实例，它负责实现接口的方法调用；
2. 通过`Proxy.newProxyInstance()`创建`interface`实例，它需要3个参数：
   1. 使用的`ClassLoader`，通常就是接口类的`ClassLoader`；
   2. 需要实现的接口数组，至少需要传入一个接口进去；
   3. 用来处理接口方法调用的`InvocationHandler`实例。
3. 将返回的`Object`强制转型为接口

即通过`Proxy`创建代理对象，然后将接口方法“代理”给`InvocationHandler`完成动态代理。

一个最简单的动态代理实现如下：

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
public class Main {
    public static void main(String[] args) {
        InvocationHandler handler = new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println(method);
                if (method.getName().equals("morning")) {
                    System.out.println("Good morning, " + args[0]);
                }
                return null;
            }
        };
        Hello hello = (Hello) Proxy.newProxyInstance(
            Hello.class.getClassLoader(), // 传入ClassLoader
            new Class[] { Hello.class }, // 传入要实现的接口
            handler); // 传入处理调用方法的InvocationHandler
        hello.morning("Bob");
    }
}
interface Hello {
    void morning(String name);
}
```
